# ---COMMENTS:

# comments are notated like this with #


# ---PREFACE:

# OBJECT SCENE MARKUP LANGUAGE

# the purpose of this format is to have unorderd
# jumbles of objects inside of scenes that can be
# addressed and loaded separately.


# ---EXAMPLE USES:

# this can be useful in any game where
# objects are mostly static

# <more here>

# ---TYPES:

# all automatic

# ints: 32, 0xFF, 0o033, 0b100101
# floats: 0.0014, 32., 12e9
# strings: "hello", ""
# bools: true, false
# VERY WEIRD lists/arrays/vectors
# NO dicts/maps

# more info in PLAIN TYPE OBJECTS section


# ---SYNTAX IN ROOT:

# this is the 'root' of the file
# this is where definitions of names happen

# inside of a scene or an object, things are very different


# ---HEADER:

# ---INCLUDES:

add example_blank.osml;

# syntax: `add <filename>.osml;`

# this adds to current namespace
# to give it its own namespace:

add example_blank2.osml as example2;

# address its components like this:
# example2.obj1
# example2.scn1

# ---META:

# the meta itself is an object
meta (
  author "Trevor Abercrombie",
)

# can be used in objects and scenes for docstrings, etc



# ---OBJECTS:

# to define:

example_obj (
  # shorthand name cannot have numbers
  # ideally one letter unless that's too vague

  a,           # attribute with only a shorthand name
  b:longB,     # longB is the real name, b is shorthand
  c = 2,       # default value
  d[1..5] = 3, # min-max values

  # real example:
    e:longE = 5, # the e-value of the object
  # |   |     |  |
  # |   |     |  docstring for argument
  # |   |     |  as a comment
  # |   |     |
  # |   |     default value
  # |   |
  # |   long name used for addressing
  # |   when short name is insufficient
  # |
  # shorthand name
)

# a few real ones for the other examples

obj ( # used for scene examples
  a:valA = 1, # value A
  b:valB = 2, # value B
  c:valC = 3, # value C
  d:valD = 4, # value D
)

rect (
  x = 0,
  y = 0,
  w:width = 10,
  h:height = 10,
)

color (
  r:red = 0,
  g:green = 0,
  b:blue = 0,
)


# ---SCENE DEFINITION:

# to define:

# this gives this scene the name `scn`
scn {
  # objects here
}


# ---SYNTAX IN SCENES:

scn_obj {

  # ---OBJECT USE:

  # args in same order as definition:
  obj 10 10 50 50;

  # defaults:
  obj 4 23;
  # because of defaults, same as:
  obj 4 23 3 4;

  # why shorthand can't have numbers:
  
  # like python would have:
  # `obj(2, 4, d=12)`
  # to keep c default,
  # we have this:
  
  obj 2 4 d12;
  # skips 3rd arg (c), leaving it default,
  # but specifies d (4th arg) by name

  # or we can do:

  obj 2 4 . 12; # keeps 3rd arg (c) default

  # also like python, you can't do a plain arg
  # after specifying one by name:

  # obj 12 b7 32;
  # bad syntax ^

  # values can be in parintheses:
  obj (2) (34) c(3) d(23);
}


# ---MORE SCENE DEFINITIONS:

# to reiterate, scenes are defined like:

scn2 {
  obj; # keeping all defaults
}
# this gives this scene the name `scn2`

# scens can contain copies of others
scn3 {
  scn2;
}

# i reiterate, COPIES.
# modifying scn3.scn2 does not modify scn2

scn4 {
  *scn2;
}
# unpacks scn2's items into scn4

# scn4 does non contain scn2 like scn3, but instead
# contains each of scn2's items, again, as COPIES

scn5 {
  subScn {
    # objects
  }
}
# this allows there to be an implicit definition of a
# scene inside another

# this does not make `subScn` a scene usable anywhere,
# but rather just makes a scene inside scn5 addressible
# as scn5.subScn

# this is bad syntax:
# scn5 {
#   {
#    # objects
#   }
# }

# the point of a scene is to be addressible by name
# which gets us to this:

# objects themselves are not usually addressible by any name
# they are technically indexible, because they are in
# a list/array/vector, but that's against the point
# of this language.

# if you really want a single addressible object, like a button
# that can be pressed, give the object an address name
button (
  x = 0,
  y = 0,
  l:push_length = 0,
  p:pushed = false,
)
scn_button {
  but:button 0 0 34;
}

# then in the real code you can do scn_button.but.pushed


# ---A BIT MORE MISC STUFF:

scn6 {
  # to change all default values of a name within a scene
  # and after a point, follow this syntax:

  ! a10 b10;

  obj; # vals: 10 10 3 4

  ! b23 d44;

  obj; # vals: 10 23 3 44

  # change relative

  ! a+3 b-4 c*2 d/4

  obj; # vals: 13 19 6 11

  # to set/change all shorthands in an entire scene copy

  scn2 ! x0 y+10;

  # to make a value exempt from this, prefix it with !
  # to overrule this when overriding, make the override use !!
  # and so on
  # the more !, the more powerful

  # for loops:

  # let's say you want to make a 100 x 100 grid of squares
  # you can't realistically do that by hand,
  # so there are for loops:

  # <var>(<start=0>;<stop>;<step=1>) {
  #   <objects>
  # }

  i(;100;) j(;100;) {
    # parintheses allow expressions,
    # but must be used when there are variables
    rect (i * 10) (j * 10) 10 10;
  }
  # for loops automatically unpack

  # if statements
  # only really useful in for loops

  
  # ? (<condition>) {
  #   <objects>
  # }

  i(;100;) j(;100;) {
    ? (i % j) {
      rect (i) (j) 10 10;
    }
    # if statements automatically unpack
  }
}



# ---ADVANCED OBJECTS:

# now that we understand how objects look in
# scenes, we can expand on them

# an object can have more advanced
# properties by adding a sub-object as
# a kind of namespace

# for example:
obj2 (
  substuff (
    a = 0,
    b = 0,
  ),
  x = 0,
  y = 0,
)

# the sub-object can be a copy of an existing one
# cannot be itself
# can use shorthands
obj3 (
  o:obj2,
)

# ---SUB OBJECT DEFAULTS + DEFINITIONS:
# this brings up:
# how do you set these values in a scene?

# like this:
scn7 {
  obj2 [1] 3 4;
}
# this sets it to:
# obj2 (
#   substuff (
#     a = 1,
#     b = 0,
#   )
#   x = 3,
#   y = 4,
# )

# and different defaults as a sub object is
# ---IN OBJECT DEFINITIONS:
obj4 (
  obj1 1 2,
  obj2 [3 7] 1 2,
  obj3 o[substuff[1 3] 5 7],
)

# you can give a sub-object a new name within
# the object, both shorthand and long
obj5 (
  s:sub<obj1,
)

# you can inherit by unpacking an object

# for example:
rect_but_different (
  *rect,
  a = 0,
  b = 0,
)

# a good example of both in action

# for example:
colored_rect (
  *rect,
  color,
)

# finally, now that we have sub-objects:
# ---BUILT IN OBJECTS:
# cannot be unpacked
# for special cases
# defy all syntax

# ---PLAIN TYPE OBJECTS:
# just for abstraction

# int <value>
# float <value>
# string <value>
# bool <value>

# ---LIST OBJECT:

# list <len/. (for dynamic)> <object type> [<default> <values>]

# let's go with storage as an example
item (
  n:name = "",
  c:count = 0,
)
storage_chest (
  o:owner = "",
  i:items<list 64 item,
)

# dynamic length example
date (
  y:year = 0,
  m:month = 0,
  d:day = 0,
)
signature (
  n:name = "",
  d:date,
)
contract (
  s:signatures<list . signature,
)

# why plain types?
# for lists of plain stuff

obj6 (
  list . int,
)



# ---HOOKS AND OBJECT TYPES:

# these aren't real, but 

button (
  x = 0,
  y = 0,
  t:type = "interactive";
  h:hook = "buttonpress";
)